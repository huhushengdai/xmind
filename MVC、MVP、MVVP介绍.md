## MVC、MVP、MVVM介绍

​		MVC、MVP、MVVM三者都是开发所使用到的设计模式，或者说架构模式。这些都是前辈大牛，为了方便项目开发、扩展、维护，从开发经验中总结出来的编程思想、设计模式。接下来就一起共同学习、探讨一下，这其中的设计思想。

#### MVC

​		[MVC](https://baike.baidu.com/item/MVC)全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。——来自百度百科

​		在上述介绍中，说得很清楚，MVC呢是把项目总的代码分成三大类：view、model、controller，三者各自负责自己的职责的代码：

​		view：负责展示数据给用户，并且响应用户的操作：如输入、点击等

​		model：负责处理业务逻辑，之后把数据提供给view。包括了获取数据（网络、数据库等）、处理数据。

​		controller：响应view事件，去选择对应的model去处理相应的业务逻辑。本身不负责处理任何业务逻辑。

![mvc结构图](https://raw.githubusercontent.com/huhushengdai/xmind/master/img/mvc/mvc.png)

​		举个栗子：

​		情景：用户输入账号密码，点“登录”按钮，成功后展示用户信息（只考虑成功情况）

​		（1） view响应用户的输入，然后在点击“登录”的时候，通知controller，用户要进行登录了，账号是XXX，密				   码是XX

​		（2） controller响应到了用户登录事件，那么他就去选择有“登录”业务逻辑的model，去真正执行登录的逻				   辑。

​		（3） 负责处理登录业务逻辑的model，处理一系列的登录业务逻辑（参数验证、网络请求），成功获取到后				   台返回的用户信息后，通知view去展示数据

​		我们就以这个例子，来具体说说，MVC模式是如何帮助我们方便项目开发、扩展、维护（备注：这里是以	MVC模式跟代码集中在一坨的情况比较，所以大家不要带入自家更优秀的模式来思考这个场景）。

​		开发：项目被分离成三个模块view、model、controller（emm，一个类里写90行代码，比起三个类里各写				    30行代码要辛苦多了），每个模块只需要处理本身的逻辑，意味着开发某一个模块时，思考的事情简					单了（只有整个项目的三分之一），并且，模块可以被多次使用、多次使用、多次使用（划重点）！

​					想想看一个场景，有十个界面都需要登录，那你是选择复制10次代码，还是选择每个界面都调用					登录model？要是要求坑爹，10个登录界面还长得不一样呢？

​		扩展：某一天，后台跟你说登录接口需要多一个参数，而此时的项目中有10个登录界面，并且这10个界面里				    面都是copy了一份登录代码！那画面简直太美，不敢相信。但是，如果项目里，这10个界面都是引用               				    同一个登录model呢？怕是后台刚说完话，你就可以跟他说：我已经改好了，什么时候一起测一下？

​		维护：同理，同样是10个登录界面。某天，另外一个同事在某个登录界面发现了一个bug并且把之修改。那么				    问题来了，他会知道其他9个界面也有同样一个bug存在么？大家可以根据这个情况使劲猜，然后思维					扩展，他要怎么办。最后，大家思维收敛回来，如果：这10个界面登录时候，都使用的是同一个登录					model...那画面是如何的美好。

​		此时，让我们重新把目光聚焦再MVC模式上，回顾一下MVC的本质：把项目代码分离成三个模块M、V、C，每个模块目标清晰，逻辑简洁，方便重复利用。

​		接下来，我们要探讨的就是，MVC模式为什么要这样设计？还记得刚刚的问题：为什么view不直接调用model，而有一个中间层controller？这里不会直接说明原因，同时下面也不会探讨这个问题，但是我们将探讨另外一个问题“controller中为什么不写任何业务逻辑”，通过对这个新问题的探讨，加上大家的思考，会得出你们想要的答案。

​		问题：controller中为什么不写任何业务逻辑？

​		其实探讨这个问题的主要原因是，很多人在以MVC模式写项目时候，都是在controller里面写业务逻辑（网络请求等），然后在model里写数据存储。这里可以有个思考：这样写也没问题啊，view、业务逻辑、db操作，也是层次清晰，目标明确，并且粒度适中，避免model里面内聚太多代码。带着思考，我们可以看图来推导一下，两者的区别。

![图1](https://raw.githubusercontent.com/huhushengdai/xmind/master/img/mvc/图1.png)

​																						图1

![图2](https://raw.githubusercontent.com/huhushengdai/xmind/master/img/mvc/图2.png)

​																						图2

​		上面两图可以看出，图1controller里面有http1、http2的业务，图2controller里面有http2、http3的业务，这里的问题在于，图1、图2都有共同的http2业务，那么要如何处理？

​		处理办法1：复制代码——基本pass

​		处理办法2：继承——controller1、controller2相同的部分http2抽离给父类，各自只需要实现各自的http1、							 http3即可。是否很完美的解决了问题？——不用copy，就能重复利用了代码（此时，too 羊，							 too 森破，该响起了）。使用继承时，就不应该忘记继承的特性，一个子类只能继承一个父类，

​							 所以，此时要是有一个controller3，跟controller2拥有相同的业务http3，那么改如何处理呢？

​		处理办法3：组合——在开发中是否经常有听到前辈的谆谆教诲：多用组合，少用继承。当然，不是说不用继							 承，而是要注意场景，这里就不对使用继承的场景进行扩展，回到我们的controller中。

![图3](https://raw.githubusercontent.com/huhushengdai/xmind/master/img/mvc/图3.png)

​																						图3

​		这把http模块跟db模块划拉到一起，是不是就成了model？然后看看controller，是不是没有业务逻辑了？只负责控制，调用哪个model，去进行业务处理。这样想想，中间层叫做controller而不是service之类的，还是有道理的——我controller只是负责控制别人去干活，至于怎么干，那不是我的职责。

![图4](https://raw.githubusercontent.com/huhushengdai/xmind/master/img/mvc/图4.png)

​		关于MVC的介绍与探讨，到这基本结束了，我们再来重新总结一下MVC：一种设计模式，把项目代码分离成三个部分view、controller、model。其中view显示数据，响应用户操作事件；controller控制中心，负责调度model去执行业务；model实际去执行业务逻辑的模块，获得数据后，通知view去更新显示。

#### MVP

​		MVP（Model-View-Presenter）实际是是MVC的衍生，也可以说是升级、改进。我们先来看看MVP的结构图，再去与MVC比较，看看是在哪里进行了改进，同时为什么要这样改进，有什么好处。

![mvp结构图](https://raw.githubusercontent.com/huhushengdai/xmind/master/img/mvc/mvp.png)

​		从图中我们可以看出，P（presenter）代替了controller，成为了控制中心，同时model也不再是获取到数据后直接通知view，而是把数据通知给presenter，再由Presenter去通知view。简单的说，就是进一步的解耦了，view跟model没有了直接关联。这里的意图很明确了，但是我们依旧不妨举个例子来分析。

​		举例之前的补充：文章在介绍MVC时候，都只是介绍概念，并没有介绍如何实现（故意的，为了做铺垫），比如如何实现model有数据后去通知view更新。在这就稍微提及一些实现方式，最常用也最简单的就是观察者模式：view注册到model里面，当有数据时，model通过持有view的引用，把数据回调过去。

​		正式举例（使用MVC情况下）：项目中，因为某些原因，要废弃model1，要使用model2作为替换，其中的数据不变。

​		这种时候，我们所要修改的地方有哪些呢？controller肯定要修改的，把调用model1，改成调用model2；view也跑不了，要从注册监听model1，改成注册监听model2（铺垫用上了）。然后老规矩，数量X10，再想想那个画面。

​		换成MVP来处理这个问题：presenter要修改是跑步掉的，毕竟直接跟model关联。然后呢？就没有然后了。在MVP的设计思想里，view跟model并没有直接关联，也就是说不论你model如何改变（当然前提是给view显示的数据不会变），都与view无关了，只能折腾presenter，这就相当于要做改变的地方只有MVC的一半了。

​		这里虽然只是针对维护来说明MVP相对于MVC的改进，但是在开发和扩展上也是有相同好处，就不一一细说。到这里MVP就基本介绍完了，跟MVC相比，有一个重要的改进，就是view跟model不再直接相关联，而已由中间的presenter来主持，把model的数据传递给view。

#### MVVM

​		如果经常使用MVP的朋友，就会发现一点非常头疼——接口非常多，需要频繁的进行接口回调。针对这种情况，MVP就相应的衍变成了MVVM。

​		MVVM（Model-View-ViewModel），这个模式很好理解，也很不好理解。好理解在于，MVVM跟MVP的基本思想是一样的，用ViewModel代替了Presenter而已；而不好理解在于，View跟ViewModel是双向绑定，而不是像View跟Presenter一样属于调用和回调的关系。

![mvvm结构图](https://raw.githubusercontent.com/huhushengdai/xmind/master/img/mvc/mvvm.png)

​		划重点：想理解MVVM跟MVP的区别，关键在于“双向绑定”。

​		关键问题：什么是双向绑定？跟普通的调用和回调有什么区别？

​		1.理解双向绑定之前，可以理解单项绑定，也就是普通的观察者模式，观察者绑定（订阅、注册）到被观察者上，当被观察者数据发生改变时，通知观察者。那么双向绑定的话，就好理解了，就是两者相互绑定（订阅）对方，当其中一方数据发生改变时，立即通知对方。在这里的双向绑定，即为View和ViewModel进行双向绑定，当其中一方数据有变化时，立即通知对方。

​		2.这双向绑定跟普通回到到底有什么区别？不同样是获取数据后，给对方么？

​		这里的区别在于：绑定

​		例子：输入框输入11位手机号后，点击“获取验证码”

​		MVP做法：点击“获取验证码”时，去获取输入框内的手机号码，然后通过调用Presenter方法时候，把手机号传值进去。

​		MVVM的做法：点击“获取验证码”时，直接调用ViewModel方法即可（不需要在方法中传入手机号）。因为View（输入框）已经跟ViewModel绑定了，每次输入时，ViewModel都会获取到输入框的值，因为输入框值发生改变时都通知了ViewModel。

​		View-ViewModel绑定之后的关系，就像人和影子，人跑到10米外的地方，跑的每一个动作都会映射到影子上面；而普通的回调呢，就像是穿越一样，直接到达目的地，没有过程。

​		讲到这里，这里会有不少朋友会想，为什么要双向绑定，这样做不反而增加了很多事么？明明一次调用，就可以把手机号号传过去，现在却要多此十举的通知11次（输入了11位）。

​		这其实就是MVVM设计的核心关键，让View跟ViewMolde绑定在一起，两者的数据相互映射，从而让开发者忽略通知的操作。简单的说，就是减少接口，以及接口回调。这里在继续说下去，就有一个难题，缺乏实际的栗子来说明MVVM如何比MVP更简洁实用的——从上面可以看出，双向绑定了，就是相互观察对方，然后接受对方改变的通知，这明明增加了工作量。

​		这个我也没有太好办法，只能祭出大招——下一篇介绍Google推出的MVVM框架“DataBinding”。从实际实用来深入探索，MVVM模式是如何比MVP模式更简便，更好用的。

​		到此，MVVM的介绍也就结束了，只有寥寥一句话总结：MVVM是对MVP的优化，由ViewMdel代替Presenter作为控制中心，并且跟View进行双向绑定，使得View和ViewModel的数据进行相互映射，其中一个发生改变之后，另一者立刻改变，不需要进行手动通知。很遗憾的是，由于MVVM这个设计模式很大程度依赖于具体细节实现，在设计思想想没有太多的变化（相对于MVP），所以只能具体介绍实现MVVM框架的时候，才能探讨一下MVVM是如何省时省力的。

​		总结：整篇文章主要介绍了MVC模式的设计思想，使用情景以及一些为什么如此设计的原因。之后在熟悉MVC的基础上，进一步介绍了MVC的衍生MVP、MVVM，希望大家有所收获。

​		